{"version":3,"file":"base-transaction.d.ts","sources":["base-transaction.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { TransactionService, Transaction, State, StateUpdateEvent } from './transaction';\nimport { EventEmitter } from '@angular/core';\nexport declare class IgxBaseTransactionService<T extends Transaction, S extends State> implements TransactionService<T, S> {\n    /**\n     * @inheritdoc\n     */\n    get canRedo(): boolean;\n    /**\n     * @inheritdoc\n     */\n    get canUndo(): boolean;\n    /**\n     * @inheritdoc\n     */\n    get enabled(): boolean;\n    /**\n     * @inheritdoc\n     */\n    onStateUpdate: EventEmitter<StateUpdateEvent>;\n    protected _isPending: boolean;\n    protected _pendingTransactions: T[];\n    protected _pendingStates: Map<any, S>;\n    /**\n     * @inheritdoc\n     */\n    add(transaction: T, recordRef?: any): void;\n    /**\n     * @inheritdoc\n     */\n    getTransactionLog(_id?: any): T[];\n    /**\n     * @inheritdoc\n     */\n    undo(): void;\n    /**\n     * @inheritdoc\n     */\n    redo(): void;\n    /**\n     * @inheritdoc\n     */\n    getAggregatedChanges(mergeChanges: boolean): T[];\n    /**\n     * @inheritdoc\n     */\n    getState(id: any): S;\n    /**\n     * @inheritdoc\n     */\n    getAggregatedValue(id: any, mergeChanges: boolean): any;\n    /**\n     * @inheritdoc\n     */\n    commit(_data: any[], _id?: any): void;\n    /**\n     * @inheritdoc\n     */\n    clear(_id?: any): void;\n    /**\n     * @inheritdoc\n     */\n    startPending(): void;\n    /**\n     * @inheritdoc\n     */\n    endPending(_commit: boolean): void;\n    /**\n     * Updates the provided states collection according to passed transaction and recordRef\n     *\n     * @param states States collection to apply the update to\n     * @param transaction Transaction to apply to the current state\n     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied\n     */\n    protected updateState(states: Map<any, S>, transaction: T, recordRef?: any): void;\n    /**\n     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types\n     *\n     * @param state State to update value for\n     * @returns updated value including all the changes in provided state\n     */\n    protected updateValue(state: S): any;\n    /**\n     * Merges second values in first value and the result in empty object. If values are primitive type\n     * returns second value if exists, or first value.\n     *\n     * @param first Value to merge into\n     * @param second Value to merge\n     */\n    protected mergeValues<U>(first: U, second: U): U;\n}\n"]}