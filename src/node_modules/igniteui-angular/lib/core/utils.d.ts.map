{"version":3,"file":"utils.d.ts","sources":["utils.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { AnimationReferenceMetadata } from '@angular/animations';\nimport { Observable } from 'rxjs';\nexport declare const mkenum: <T extends {\n    [index: string]: U;\n}, U extends string>(x: T) => T;\n/**\n * Returns the ResizeObserver type or the polyfilled version if not available.\n *\n * @hidden @internal\n */\nexport declare const getResizeObserver: () => {\n    new (callback: ResizeObserverCallback): ResizeObserver;\n    prototype: ResizeObserver;\n};\n/**\n * @hidden\n */\nexport declare const cloneArray: (array: any[], deep?: boolean) => any[];\n/**\n * Doesn't clone leaf items\n *\n * @hidden\n */\nexport declare const cloneHierarchicalArray: (array: any[], childDataKey: any) => any[];\n/**\n * Deep clones all first level keys of Obj2 and merges them to Obj1\n *\n * @param obj1 Object to merge into\n * @param obj2 Object to merge from\n * @returns Obj1 with merged cloned keys from Obj2\n * @hidden\n */\nexport declare const mergeObjects: (obj1: any, obj2: any) => any;\n/**\n * Creates deep clone of provided value.\n * Supports primitive values, dates and objects.\n * If passed value is array returns shallow copy of the array.\n *\n * @param value value to clone\n * @returns Deep copy of provided value\n * @hidden\n */\nexport declare const cloneValue: (value: any) => any;\n/**\n * Parse provided input to Date.\n *\n * @param value input to parse\n * @returns Date if parse succeed or null\n * @hidden\n */\nexport declare const parseDate: (value: any) => Date | null;\n/**\n * Returns an array with unique dates only.\n *\n * @param columnValues collection of date values (might be numbers or ISO 8601 strings)\n * @returns collection of unique dates.\n * @hidden\n */\nexport declare const uniqueDates: (columnValues: any[]) => any;\n/**\n * Checks if provided variable is Object\n *\n * @param value Value to check\n * @returns true if provided variable is Object\n * @hidden\n */\nexport declare const isObject: (value: any) => boolean;\n/**\n * Checks if provided variable is Date\n *\n * @param value Value to check\n * @returns true if provided variable is Date\n * @hidden\n */\nexport declare const isDate: (value: any) => value is Date;\n/**\n * Checks if the two passed arguments are equal\n * Currently supports date objects\n *\n * @param obj1\n * @param obj2\n * @returns: `boolean`\n * @hidden\n */\nexport declare const isEqual: (obj1: any, obj2: any) => boolean;\n/**\n * Utility service taking care of various utility functions such as\n * detecting browser features, general cross browser DOM manipulation, etc.\n *\n * @hidden @internal\n */\nexport declare class PlatformUtil {\n    private platformId;\n    isBrowser: boolean;\n    isIOS: boolean;\n    isFirefox: boolean;\n    isEdge: boolean;\n    isIE: boolean;\n    KEYMAP: {\n        ENTER: \"Enter\";\n        SPACE: \"Spacebar\" | \" \";\n        ESCAPE: \"Esc\" | \"Escape\";\n        ARROW_DOWN: \"Down\" | \"ArrowDown\";\n        ARROW_UP: \"Up\" | \"ArrowUp\";\n        ARROW_LEFT: \"Left\" | \"ArrowLeft\";\n        ARROW_RIGHT: \"Right\" | \"ArrowRight\";\n        END: \"End\";\n        HOME: \"Home\";\n        PAGE_DOWN: \"PageDown\";\n        PAGE_UP: \"PageUp\";\n        F2: \"F2\";\n        TAB: \"Tab\";\n        SEMICOLON: \";\";\n        DELETE: \"Del\" | \"Delete\";\n        BACKSPACE: \"Backspace\";\n        CONTROL: \"Control\";\n        X: \"x\";\n        Y: \"y\";\n        Z: \"z\";\n    };\n    constructor(platformId: any);\n    /**\n     * @hidden @internal\n     * Returns the actual size of the node content, using Range\n     * ```typescript\n     * let range = document.createRange();\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     *\n     * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);\n     *\n     * @remarks\n     * The last parameter is useful when the size of the element to measure is modified by a\n     * parent element that has explicit size. In such cases the calculated size is never lower\n     * and the function may instead remove the parent size while measuring to get the correct value.\n     * ```\n     */\n    getNodeSizeViaRange(range: Range, node: HTMLElement, sizeHoldingNode?: HTMLElement): number;\n    /**\n     * Returns true if the current keyboard event is an activation key (Enter/Space bar)\n     *\n     * @hidden\n     * @internal\n     *\n     * @memberof PlatformUtil\n     */\n    isActivationKey(event: KeyboardEvent): boolean;\n    /**\n     * Returns true if the current keyboard event is a combination that closes the filtering UI of the grid. (Escape/Ctrl+Shift+L)\n     *\n     * @hidden\n     * @internal\n     * @param event\n     * @memberof PlatformUtil\n     */\n    isFilteringKeyCombo(event: KeyboardEvent): boolean;\n    /**\n     * @hidden @internal\n     */\n    isLeftClick(event: PointerEvent | MouseEvent): boolean;\n    /**\n     * @hidden @internal\n     */\n    isNavigationKey(key: string): boolean;\n}\n/**\n * @hidden\n */\nexport declare const flatten: (arr: any[]) => any[];\nexport interface CancelableEventArgs {\n    /**\n     * Provides the ability to cancel the event.\n     */\n    cancel: boolean;\n}\nexport interface IBaseEventArgs {\n    /**\n     * Provides reference to the owner component.\n     */\n    owner?: any;\n}\nexport interface CancelableBrowserEventArgs extends CancelableEventArgs {\n    /** Browser event */\n    event?: Event;\n}\nexport interface IBaseCancelableBrowserEventArgs extends CancelableBrowserEventArgs, IBaseEventArgs {\n}\nexport interface IBaseCancelableEventArgs extends CancelableEventArgs, IBaseEventArgs {\n}\nexport declare const HORIZONTAL_NAV_KEYS: Set<string>;\nexport declare const NAVIGATION_KEYS: Set<string>;\nexport declare const ROW_EXPAND_KEYS: Set<string>;\nexport declare const ROW_COLLAPSE_KEYS: Set<string>;\nexport declare const ROW_ADD_KEYS: Set<string>;\nexport declare const SUPPORTED_KEYS: Set<string>;\nexport declare const HEADER_KEYS: Set<string>;\n/**\n * @hidden\n * @internal\n *\n * Creates a new ResizeObserver on `target` and returns it as an Observable.\n * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.\n * Related issue: https://github.com/angular/angular/issues/31712\n */\nexport declare const resizeObservable: (target: HTMLElement) => Observable<ResizeObserverEntry[]>;\n/**\n * @hidden\n * @internal\n *\n * Compares two maps.\n */\nexport declare const compareMaps: (map1: Map<any, any>, map2: Map<any, any>) => boolean;\n/**\n *\n * Given a property access path in the format `x.y.z` resolves and returns\n * the value of the `z` property in the passed object.\n *\n * @hidden\n * @internal\n */\nexport declare const resolveNestedPath: (obj: any, path: string) => any;\n/**\n *\n * Given a property access path in the format `x.y.z` and a value\n * this functions builds and returns an object following the access path.\n *\n * @example\n * ```typescript\n * console.log('x.y.z.', 42);\n * >> { x: { y: { z: 42 } } }\n * ```\n *\n * @hidden\n * @internal\n */\nexport declare const reverseMapper: (path: string, value: any) => {};\nexport declare const yieldingLoop: (count: number, chunkSize: number, callback: (index: number) => void, done: () => void) => void;\nexport declare const reverseAnimationResolver: (animation: AnimationReferenceMetadata) => AnimationReferenceMetadata;\nexport declare const isHorizontalAnimation: (animation: AnimationReferenceMetadata) => boolean;\nexport declare const isVerticalAnimation: (animation: AnimationReferenceMetadata) => boolean;\n"]}